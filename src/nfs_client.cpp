/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>
#include <limits>
#include <sstream>
#include "nfs.h"

static CLIENT *clnt;

char *ls_cmd(std::string ls_1_str);
int create_cmd(std::string create_1_filename);
int mkdir_cmd(std::string mkdir_1_filename);
int delete_cmd(std::string delete_1_filename);
void sendfile(std::string filename);
void senddir(std::string dirname);
void send_cmd(std::string send_1_filename);
void retrieve_cmd(std::string retrieve_1_filename);
void retrievefile(std::string filename);
void retrievedir(std::string filename);


void init_clnt(char *host) {
	#ifndef	DEBUG
		clnt = clnt_create (host, NFS_PROGRAM, NFS_VERSION_1, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
}

void destroy_clnt() {
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}



char *ls_cmd(std::string ls_1_str) {
	char **result = ls_1((char *) ls_1_str.c_str(), clnt);
	if (result == (char **) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return *result;
}

int create_cmd(std::string create_1_filename) {
	int *result = create_1((char *) create_1_filename.c_str(), clnt);
	if (result == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result == E_FILENAME_INVALID)
		std::cout << "ERROR: Filename '" << create_1_filename << "' is invalid.\n";
	else if (*result == E_FILE_EXISTS)
		std::cout << "WARNING: File '" << create_1_filename << "' already existed and was truncated.\n";

	return *result;
}

int mkdir_cmd(std::string mkdir_1_filename) {
	int *result = mkdir_1((char *) mkdir_1_filename.c_str(), clnt);

	if (result == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result == E_FILENAME_INVALID)
		std::cout << "ERROR: Filename '" << mkdir_1_filename << "' is invalid.\n";
	else if (*result == E_FILE_EXISTS)
		std::cout << "WARNING: File '" << mkdir_1_filename << "' already existed and was truncated.\n";

	return *result;
}

int delete_cmd(std::string delete_1_filename) {
	int *result = delete_1((char *) delete_1_filename.c_str(), clnt);
	if (result == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result == E_FILENAME_INVALID)
		std::cout << "ERROR: Filename '" << delete_1_filename << "' is invalid.\n";
	else if (*result == E_FILE_NOT_EXISTS)
		std::cout << "ERROR: File '" << delete_1_filename << "' does not exist.\n";

	return *result;
}

void send_cmd(std::string send_1_filename) {
	//first, check if the file exists locally
	if (access(send_1_filename.c_str(), F_OK) != 0) {
    std::cout << "ERROR: File '" << send_1_filename << "' does not exist.\n";
		return;
	}

	struct stat st;

	stat(send_1_filename.c_str(), &st);
	if (S_ISREG(st.st_mode))
		sendfile(send_1_filename);
	else if (S_ISDIR(st.st_mode))
		senddir(send_1_filename);
}

void sendfile(std::string filename) {
	//first, create an empty file server-side
	create_1((char *) filename.c_str(), clnt);
	FILE *file = fopen(filename.c_str(), "r");

	int pos = 0;
	chunk ch;
	ch.filename = (char *) filename.c_str();
	ch.data.data_val = (char *) malloc(DATA_LENGTH * sizeof(char));

	do {
		ch.data.data_len = fread(ch.data.data_val, 1, DATA_LENGTH, file);
		ch.dest_offset = pos;
		pos += ch.data.data_len;

		int *result = send_file_1(ch, clnt);

		if (result == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}

	} while (ch.data.data_len == DATA_LENGTH);

	//TODO free() all malloc()'s
	free(ch.data.data_val);
	fclose(file);
}

void senddir(std::string dirname) {
	mkdir_cmd(dirname);

	DIR* d = opendir(dirname.c_str());

  for(struct dirent *de = NULL; (de = readdir(d)) != NULL;) {
    if (de->d_name[0] != '.')
			send_cmd(dirname + "/" + std::string(de->d_name));
  }

  closedir(d);
}


void retrieve_cmd(std::string retrieve_1_filename) {
	//first, check if the file exists locally
	if (retrieve_1_filename.back() == '/')
		retrieve_1_filename = retrieve_1_filename.substr(0, retrieve_1_filename.length() - 1);

	int pos = 0;
	request req;
	chunk *ch = NULL;
	FILE *file;

  req.filename = (char *) retrieve_1_filename.c_str();
	do {
		req.offset = pos;
		pos += DATA_LENGTH;

    ch = retrieve_file_1(req, clnt);
		//TODO check if exists -> E_FILE_NOT_EXISTS, T_FILE, T_DIR
		if (ch->status == T_DIR) {
			retrievedir(retrieve_1_filename);
			return;
		}
		if (ch->status == E_FILE_NOT_EXISTS) //if file does not exist
			break;

		if (req.offset == 0)
			file = fopen(retrieve_1_filename.c_str(), "w");
		if (ch == (chunk *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		fseek(file, ch->dest_offset, SEEK_SET);
	  fwrite(ch->data.data_val, 1, ch->data.data_len, file);

  } while (ch->data.data_len == DATA_LENGTH);

	//TODO free() all malloc()'s
	// free(ch.data.data_val);

  fclose(file);
	if (ch->status == E_FILE_NOT_EXISTS) { //if file does not exist
		remove(retrieve_1_filename.c_str());
		std::cout << "ERROR: File '" << retrieve_1_filename << "' does not exist.\n";
	}
}

void retrievefile(std::string filename) {

}

void retrievedir(std::string filename) {
	mkdir(filename.c_str(), 0700);

	std::string str_result = std::string(ls_cmd(filename));
	std::istringstream sstr_result(str_result);
	if (str_result.length() == 0)
		return; //directory empty

	std::string eachfile;
	while(sstr_result >> eachfile) {
		sstr_result.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

		retrieve_cmd(filename + "/" + eachfile);
	}
}

//returns boolean that says wheter another command should be read
//if false, program should exit
bool read_command()
{
	//TODO refactor
  std::string command;

  std::cout << "> ";
	fflush(stdin);
  std::cin >> command;

  if (command == "ls") {
		std::string location;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      location = "."; 							//and assign the default
    } else {
        std::cin >> location;
    }
		char *result = ls_cmd(location);
		std::cout << std::endl << result << std::endl;
	} else if (command == "create") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: create <filename>\n";
    } else {
      std::cin >> filename;
      create_cmd(filename);
    }
  } else if (command == "delete") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: delete <filename>\n";
    } else {
      std::cin >> filename;
      delete_cmd(filename);
    }
  } else if (command == "send") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: send <filename>\n";
    } else {
      std::cin >> filename;
      send_cmd(filename);
    } //TODO check if file to send exists
  } else if (command == "get") {
		std::string filename; //TODO everywhere is one parameter taken -> DRY
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: get <filename>\n";
    } else {
      std::cin >> filename;
      retrieve_cmd(filename);
    } //TODO check if file to send exists
  } else if (command == "mkdir") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: mkdir <filename>\n";
    } else {
      std::cin >> filename;
      mkdir_cmd(filename);
    } //TODO check if file to send exists
  } else if (command.compare("exit") == 0 || command.compare("quit") == 0) {
		return false;
  } else {
    std::cout << "!Invalid command '" << command << "'\n";
		std::cin.clear();
		std::cin.ignore(INT_MAX, '\n');
		//TODO help
	}
	return true;
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s <server_host>\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	init_clnt(host);

	while(read_command() != false);

	destroy_clnt();
}
