/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <dirent.h>
#include <string>
#include <sstream>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <iostream>
#include <iomanip>
#include <fcntl.h>

#include "nfs.h"

char* ls_dir(std::string path);
char ** ls_1_svc(char *str,  struct svc_req *rqstp);
int *create_1_svc(char *filename,  struct svc_req *rqstp);
int *delete_1_svc(char *filename,  struct svc_req *rqstp);
chunk *retrieve_file_1_svc(request req,  struct svc_req *rqstp);
int *send_file_1_svc(chunk ch,  struct svc_req *rqstp);
int *mkdir_1_svc(char *dirname,  struct svc_req *rqstp);
chunk retrievefile(request req);
chunk retrievedir(request req);


std::string format_size(long size) {
	std::ostringstream formatted;

	if (size < 1024)
		formatted << size << " B";
	else if (size < 1024 * 1024)
		formatted << size / 1024 << " KB";
	else if (size < 1024 * 1024 * 1024)
		formatted << size / 1024 / 1024 << " MB";

	return formatted.str();
}

bool is_filename_valid(std::string filename) {
	std::string dotdot = "..";
	if (filename.find(dotdot) != std::string::npos)
		return false;
	return true;
}

char* ls_dir(std::string path) {
	std::ostringstream files;

  DIR* d = opendir(path.c_str());
  if (d == NULL) return NULL;

	struct stat st;

  for(struct dirent *de = NULL; (de = readdir(d)) != NULL; ) {
    stat(de->d_name, &st);
  	if (de->d_type == DT_REG)
    	files << std::left << std::setw(MAX_LENGTH) << de->d_name << de->d_type
				<< format_size(st.st_size) << std::endl;
		else if (de->d_type == DT_DIR && de->d_name[0] != '.')
			files << de->d_name << "/" << std::endl;
  }

  closedir(d);
	// std::cout << files.str() << std::endl;
	char *cstr = new char[files.str().length() + 1];
	strncpy(cstr, files.str().c_str(), files.str().length());
	cstr[files.str().length()] = '\0';
	return cstr;
}

char ** ls_1_svc(char *str,  struct svc_req *rqstp)
{
	static char * result;
	std::cout << "Listed files\n";
	result = ls_dir(std::string(str));

	return &result;
}

int *
create_1_svc(char *filename,  struct svc_req *rqstp)
{
	static int result;

	std::cout << "Received request to create a file with name '" << filename << "'\n";
	result = NO_ERROR;
	if (!is_filename_valid(std::string(filename)))
		result = E_FILENAME_INVALID;
	if (access(filename, F_OK) == 0)
    result = E_FILE_EXISTS;

	if (result != E_FILENAME_INVALID) {
		fopen(filename, "w");
		std::cout << "Created/truncated '" << filename << "'\n";
	}
	return &result;
}

int * delete_1_svc(char *filename,  struct svc_req *rqstp)
{
	static int result;
	//TODO DRY, result = NO_ERROR;?
	//TODO UDP
	std::cout << "Received request to delete a file with name '" << filename << "'\n";
	result = NO_ERROR;
	if (!is_filename_valid(std::string(filename)))
		result = E_FILENAME_INVALID;
	if (access(filename, F_OK) != 0)
    result = E_FILE_NOT_EXISTS;

	if (result == NO_ERROR) {
		remove(filename);
		std::string command = "rm -rf " + std::string(filename);
		system(command.c_str());
		std::cout << "Deleted '" << filename << "'\n";
	}
	return &result;
}

chunk * retrieve_file_1_svc(request req,  struct svc_req *rqstp)
{
	static chunk ch;
	//clear previous ch
	ch.dest_offset = req.offset;
	ch.filename = req.filename;
	ch.data.data_len = 0;
	ch.data.data_val = NULL;

	struct stat st;

	if (req.offset == 0)
		std::cout << "Requested file '" << req.filename << "'\n";

	if (access(req.filename, F_OK) != 0)
    ch.status = E_FILE_NOT_EXISTS;
	else {
		stat(req.filename, &st);
		if (S_ISREG(st.st_mode))
			ch = retrievefile(req);
		else if (S_ISDIR(st.st_mode))
			ch = retrievedir(req);
	}
	std::cout << "Returned " << ch.status << std::endl;

	return &ch;
}

chunk retrievefile(request req) {
	chunk ch;
	FILE *file;
  file = fopen(req.filename, "r");

	ch.status = T_FILE;

	fseek(file, req.offset, SEEK_SET);
	ch.data.data_val = (char *) malloc(DATA_LENGTH * sizeof(char));
	ch.data.data_len = fread(ch.data.data_val, 1, DATA_LENGTH, file);
	ch.dest_offset = req.offset;
	ch.filename = req.filename;
  fclose(file);

	std::cout << ch.status << std::endl;

	return ch;
}

chunk retrievedir(request req) {
	chunk ch;
	ch.status = T_DIR;
	ch.filename = req.filename;
	//TODO have to malloc?

	return ch;
}

int * send_file_1_svc(chunk ch,  struct svc_req *rqstp)
{
	static int result;
  result = NO_ERROR;

	FILE *file;
  file = fopen(ch.filename, "a");
  if (file == NULL) {
      result = errno;
      return &result;
  }

	fseek(file, ch.dest_offset, SEEK_SET);
  fwrite(ch.data.data_val, 1, ch.data.data_len, file);
  fclose(file);

	if (ch.dest_offset == 0)
		std::cout << "Received file '" << ch.filename << "'\n";

	return &result;
}

int * mkdir_1_svc(char *dirname,  struct svc_req *rqstp)
{
	static int result;

	std::cout << "Received request to create a directory with name '" << dirname << "'\n";
	result = NO_ERROR;
	if (!is_filename_valid(std::string(dirname)))
		result = E_FILENAME_INVALID;
	if (access(dirname, F_OK) == 0)
    result = E_FILE_EXISTS;

	if (result != E_FILENAME_INVALID) {
		mkdir(dirname, 0700);
		std::cout << "Created '" << dirname << "'\n";
	}
	return &result;
}

int *
exists_1_svc(char *filename,  struct svc_req *rqstp)
{
	static int result;
	result = NO_ERROR;
	struct stat st;

	if (!is_filename_valid(std::string(filename)))
		result = E_FILENAME_INVALID;
	else if (access(filename, F_OK) != 0)
		result = E_FILE_NOT_EXISTS;
	else {
		stat(filename, &st);
		if (S_ISREG(st.st_mode))
			result = T_FILE;
		else if (S_ISDIR(st.st_mode))
			result = T_DIR;
	}

	return &result;
}
