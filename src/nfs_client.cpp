/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <iostream>
#include <unistd.h>
#include "nfs.h"

static CLIENT *clnt;

void init_clnt(char *host) {
	#ifndef	DEBUG
		clnt = clnt_create (host, NFS_PROGRAM, NFS_VERSION_1, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
}

void destroy_clnt() {
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

char *ls_cmd(std::string ls_1_str) {
	char **result = ls_1((char *) ls_1_str.c_str(), clnt);
	if (result == (char **) NULL) {
		clnt_perror (clnt, "call failed");
	}

	return *result;
}

int create_cmd(std::string create_1_filename) {
	int *result = create_1((char *) create_1_filename.c_str(), clnt);
	if (result == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result == E_FILENAME_INVALID)
		std::cout << "ERROR: Filename '" << create_1_filename << "' is invalid.\n";
	else if (*result == E_FILE_EXISTS)
		std::cout << "ERROR: File '" << create_1_filename << "' already existed and was truncated.\n";

	return *result;
}

int delete_cmd(std::string delete_1_filename) {
	int *result = delete_1((char *) delete_1_filename.c_str(), clnt);
	if (result == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}

	if (*result == E_FILENAME_INVALID)
		std::cout << "ERROR: Filename '" << delete_1_filename << "' is invalid.\n";
	else if (*result == E_FILE_NOT_EXISTS)
		std::cout << "ERROR: File '" << delete_1_filename << "' does not exist.\n";

	return *result;
}

void send_cmd(std::string send_1_filename) {
	//first, check if the file exists locally
	if (access(send_1_filename.c_str(), F_OK) != 0) {
    std::cout << "ERROR: File '" << send_1_filename << "' does not exist.\n";
		return;
	}

	//then, create an empty file server-side
	create_1((char *) send_1_filename.c_str(), clnt);

	FILE *file = fopen(send_1_filename.c_str(), "r");

	int pos = 0;
	chunk ch;
  ch.filename = (char *) send_1_filename.c_str();
	ch.data.data_val = (char *) malloc(DATA_LENGTH * sizeof(char));

	do {
    ch.data.data_len = fread(ch.data.data_val, 1, DATA_LENGTH, file);
		ch.dest_offset = pos;
		pos += ch.data.data_len;

    int *result = send_file_1(ch, clnt);

		if (result == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}

  } while (ch.data.data_len == DATA_LENGTH);

	//TODO free() all malloc()'s
	free(ch.data.data_val);
  fclose(file);

}

void retrieve_cmd(std::string retrieve_1_filename) {
	//first, check if the file exists locally
	FILE *file = fopen(retrieve_1_filename.c_str(), "w");

	int pos = 0;
	request req;
	chunk *ch = NULL;

  req.filename = (char *) retrieve_1_filename.c_str();
	do {
		req.offset = pos;
		pos += DATA_LENGTH;

    ch = retrieve_file_1(req, clnt);
		if (ch->status == E_FILE_NOT_EXISTS) //if file does not exist
			break;

		if (ch == (chunk *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		fseek(file, ch->dest_offset, SEEK_SET);
	  fwrite(ch->data.data_val, 1, ch->data.data_len, file);

  } while (ch->data.data_len == DATA_LENGTH);

	//TODO free() all malloc()'s
	// free(ch.data.data_val);

  fclose(file);
	if (ch->status == E_FILE_NOT_EXISTS) { //if file does not exist
		remove(retrieve_1_filename.c_str());
		std::cout << "ERROR: File '" << retrieve_1_filename << "' does not exist.\n";
	}
}

//returns boolean that says wheter another command should be read
//if false, program should exit
bool read_command()
{
	//TODO refactor
  std::string command;

  std::cout << "> ";
	fflush(stdin);
  std::cin >> command;

  if (command == "ls") {
		std::string location;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      location = "."; 							//and assign the default
    } else {
        std::cin >> location;
    }
		char *result = ls_cmd(location);
		std::cout << std::endl << result << std::endl;

	} else if (command == "create") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: create <filename>\n";
    } else {
      std::cin >> filename;
      create_cmd(filename);
    }
  } else if (command == "delete") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: delete <filename>\n";
    } else {
      std::cin >> filename;
      delete_cmd(filename);
    }
  } else if (command == "send") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: send <filename>\n";
    } else {
      std::cin >> filename;
      send_cmd(filename);
    } //TODO check if file to send exists
  } else if (command == "get") {
		std::string filename;
		if (std::cin.peek() == '\n') { 	//check if next character is newline
      std::cout << "You must give a filename: get <filename>\n";
    } else {
      std::cin >> filename;
      retrieve_cmd(filename);
    } //TODO check if file to send exists
  } else if (command.compare("exit") == 0 || command.compare("quit") == 0) {
		return false;
  } else {
    std::cout << "!Invalid command '" << command << "'\n";
		std::cin.clear();
		std::cin.ignore(INT_MAX, '\n');
		//TODO help
	}
	return true;
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s <server_host>\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	init_clnt(host);

	while(read_command() != false);

	destroy_clnt();
}
